下面的程序为什么不能按照想法运行，子程序没有调用SIGINT中断函数-----------------------------------------------------------
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<sys/types.h>
#include<signal.h>

int alarm_fired=0;

void ouch(int sig)
{
alarm_fired=1;
printf("set the alarm_fired=1,signal=%d\n",sig);
}

int main()
{
pid_t pid;
pid=fork();
switch(pid){
case -1:
perror("fork error\n");
case 0:
sleep(5);
kill(getppid(),SIGALRM);
signal(SIGINT,ouch);
break;

default:
signal(SIGALRM,ouch);
break;
}
while(!alarm_fired){
printf("hello world\n");
sleep(1);
}
return 0;
}
文件锁没有起作用，原因是什么-------------------------------------------------------------------------------
#include <unistd.h>
#include <sys/file.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include<sys/wait.h>
#include<string.h>

int lock_reg(int fd,int cmd,int type)
{
	struct flock lock;
	lock.l_type=type;
	lock.l_start=0;
	lock.l_whence=SEEK_SET;
	lock.l_len=0;
	if(fcntl(fd,cmd,&lock)==-1)
		printf("fcntl error\n");
}

int main()
{
	pid_t pid;
	char *buf1="wo shi fu qin";
	char *buf2="zhe ge shi haizi";
	int fd;
	char buf[1024];
	unlink("./lock");
	fd=open("./lock",O_RDWR|O_CREAT);
	printf("the fd=%d\n",fd);
	if((pid=fork())<0)
		printf("fork error\n");
	else if(pid==0)
		{	
			int n;
			printf("in the child\n");
			lock_reg(fd,F_SETLK,F_WRLCK);
			n=write(fd,buf2,strlen(buf2));
			printf("the n=%d\n",n);
			sleep(2);
			write(fd,buf2,strlen(buf2));
			
			
		}
		else if(pid>0){
			sleep(1);
			printf("in the father\n");
			write(fd,buf1,strlen(buf1));
			//lseek(fd,0,SEEK_SET);
			//read(fd,buf,sizeof(buf));
			//printf("the buf=%s\n",buf);
		}
}

