1、UDP通信中只有recvfrom默认是阻塞的，其它都是非阻塞的；
2、TCP通信中只有accept、send/write（send或者write如果缓冲区满了就阻塞）默认是阻塞的，其它都是非阻塞的，一旦accept成功返回表面客户端和服务器端建立了连接了，
之后的send和recv和读写文件中的read，write操作一样，TCP属于套接字流的一种，也和文件操作一样输入流的操作，将接收和发送缓冲区当作文件来读写。
3、TCP通信，从写一个TCP套接口的write/send调用成功返回仅仅表示我们可以重新使用应用进程缓冲区，
它并不是告诉我们对方收到数据。TCP发给对方的数据，对方在收到数据时必须给矛确认ACK，只有在收到对方的确认时，本方TCP才会把TCP发送缓冲区中的数据删除。

setsockopt可以设置端口复用，也可以设置rcev和send阻塞时间

关于TCP:
每一个TCP套接字都有一个发送缓冲区，可以使用SO_SNDBUF套接字选项来更改缓冲区大小。
我们调用send发送数据的时候(默认阻塞模式)，如果缓冲区没满，调用直接返回。但是这仅仅表明数据被复制到缓冲区中，
并不表明对端接收到数据。系统内核在IP层发送数据的时候，并不是按照我们调用send接口发送的数据包大小来进行发送，
即使我们调用send发送的数据大小小于1460字节(MTU-TCP首部-IP首部)。因为我们调用send接口实际是将数据复制到缓冲区中，
而内核基本上是按照最大MSS大小(1460字节)从缓冲区中取数据发送出去，当缓冲区中数据小于MSS，则将剩余数据全部发送出去。
TCP的发送缓冲区必须为已发送的数据保留一个副本，直到它被对端确认为止，才能从缓冲区中删掉已确认的数据。
TCP接收缓冲区，可以通过SO_RCVBUF套接字选项来更改。
接收缓冲区被TCP用来保存接收到的数据，直到应用程序来读取。对于TCP来说，接收缓冲区中可用空间的大小限定了TCP通告对端的窗口大小。
TCP套接字的接收缓冲区不能溢出，所以发送端不能发送超过接收端通知的窗口大小，否则在接收端将丢弃数据包。

关于UDP：
UDP也有发送缓冲区大小，也可以通过SO_SNDBUF套接字选项更改它，不过它不同于TCP的发送缓冲区大小，
它仅仅是可以写到该套接字的UDP数据报的大小上限。如果一个应用程序写一个大于套接字发送缓冲区大小的数据报，
内核将返回一个EMSGSIZE错误。UDP缓冲区中数据被发送完之后，该数据就被删除了。我们调用sendto发送数据的时候，
内核在收到用户的数据报，仅仅给数据包加上8字节的首部构成UDP数据报，然后就传给IP层。如果数据报大小小于MTU，则直接发送给对端；
如果大于MTU，则会被分片。所以通过UDP协议发送数据报，应该考虑发送的数据包小于MTU-8(UDP首部)-20(IP首部)，
这样在通过IP层就不用分片，丢包率将比分片处理的情况小很多。
UDP的接收缓冲区，同样通过SO_RCVBUF套接字选项更改它。当接收到的数据报装不进接收缓冲区，该数据报就被丢弃。
UDP因为是不可靠连接，不必保存应用进程的数据拷贝，应用进程中的数据在沿协议栈向下传递时，以某种形式拷贝到内核缓冲区，
当数据链路层把数据传出后就把内核缓冲区中数据拷贝删除。因此它不需要一个发送缓冲区。
写UDP套接口的write返回表示应用程序的数据或数据分片已经进入链路层的输出队列，如果输出队列没有足够的空间存放数据，将返回错误ENOBUFS.

